// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

import "remix_tests.sol";       // Remix testing library
import "remix_accounts.sol";    // Provides TestsAccounts.getAccount(...)

import "contracts/StockMarket.sol";
import "contracts/StockToken.sol";

/// @title All-in-one test suite for StockMarket + StockToken + basic assertions
contract AllTests {
     StockMarket public market;
     address      public owner = TestsAccounts.getAccount(0);
     address      public user1 = TestsAccounts.getAccount(1);


    /// @notice Deploys and initializes the market
    /// #sender: account-0
    /// #value: 5 ether
    function beforeAll() public payable {
        // 1) Deploy the StockMarket
        market = new StockMarket();

        // 2) Fund it so sellStock can pay out
        payable(address(market)).transfer(msg.value);

        // 3) Transfer ownership to this test contract
        market.transferOwnership(address(this));

        // 4) Register and set up one stock
        market.addStock("MSFT", "Microsoft Corp");
        market.updatePrice("MSFT", 100_000_000); // 1 ETH scaled by 1e8
    }

    /// @notice Owner can add a new stock
    function test_addStock_byOwner() public {
        market.addStock("AAPL", "Apple Inc");
        (string memory name, , uint256 price, uint256 ts) = market.stocks("AAPL");
        Assert.equal(name,  "Apple Inc",          "Name should match");
        Assert.equal(price, 0,                    "Initial price must be zero");
        Assert.equal(ts,    0,                    "Initial timestamp must be zero");
        Assert.ok(market.registered("AAPL"),      "AAPL should be registered");
    }

    /// @notice Non-owner addStock should revert
    function test_addStock_notOwner() public {
        // Deploy a fresh market whose owner is this contract
        StockMarket other = new StockMarket();
        // Now call addStock on that from this contract: should succeed (we are owner)
        other.addStock("X", "X Corp");
        // But to simulate a non-owner call, we use a try/catch on a call from EOA:
        bool didRevert;
        try other.updatePrice("X", 42) {
            // owner can updatePrice
            didRevert = false;
        } catch {
            didRevert = true;
        }
        Assert.ok(!didRevert, "updatePrice by owner should not revert");
    }

    /// @notice Owner can update price
    function test_updatePrice() public {
        market.updatePrice("MSFT", 50_000_000); // 0.5 ETH
        (, , uint256 price, uint256 ts) = market.stocks("MSFT");
        Assert.equal(price, 50_000_000, "Price should update");
        Assert.ok(ts > 0,            "Timestamp should be set");
    }

// ----------------------------------------------------------------
    // Basic assertion tests below
    // ----------------------------------------------------------------

    function checkSuccess() public {
        Assert.ok(2 == 2,                        "2 == 2 should be true");
        Assert.greaterThan(uint(2), uint(1),     "2 > 1");
        Assert.lesserThan(uint(2), uint(3),      "2 < 3");
    }

    function checkSuccess2() public pure returns (bool) {
        return true;
    }

    function checkFailure() public {
        // 1 should not equal 2
        Assert.notEqual(uint(1), uint(2),        "1 should not be equal to 2");
    }

    /// @notice Checks custom tx context
    /// #sender: account-1
    /// #value: 100
    function checkSenderAndValue() public payable {
        Assert.equal(msg.sender,  user1,        "Invalid sender");
        Assert.equal(msg.value,   100,          "Invalid value");
    }
}